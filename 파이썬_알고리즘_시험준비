1
**인터프리터 언어가 뭔지? 
위에서부터 아래에서 도달
**범용 프로그래밍 언어로 (다양하게 쓰인다)
간결, 가독성이 좋다
배우기 쉽다
구글 소프트웨어의 많은 부분이 파이썬으로 작성**(타 언어와의 높은 호환성)
js는 next.js, node, react...

2
stackoverflow 참고해서 인기 있는 언어 등등 알아보기

3
무료
빠른 개발 속도 <> **단점은 실행속도가 느리다
**다양한 패키지 제공(라이브러리, 모듈 다양)
단점은 모바일 어플리케이션 없음
데이터 크롤링 가능

4
Vim은 나중에 서버 같은 거 이용하면서 자주 쓰는 에디터임
ESC로 나온 후 shift + 세미콜론 + wq 로 저장
i가 insert (리눅스 기반)

5
통합개발환경(IDE) : vscode 같은

6
**코딩 시 주의해서 써야 할 것!!
들여쓰기, 네이밍컨벤션(PEP8), 주석, 모듈과 패키지(pip로 설치 가능), 예외처리

7
변수 : 데이터를 저장하기 위한 메모리 공간에 이름을 붙인 것
동적 타이핑 언어인 파이썬은 데이터 타입을 지정하지 않아도 됨!!
**변수명으로 적합하지 않은 것은?

8
보통 루프 변수나 간단한 임시 변수에만 단일 문자 변수를 사용한다.
예를 들어, i나 temp

9
**파이썬문법에 사용되는 단어 (소문자로) 이런건 변수명으로 사용 못하니까..

10
숫자는 정수, 실수만
허수 j는 루트 -1

11
문자열
파이썬에서는 백틱을 지원하지 않는다..
**시퀀스 객체 : 한번 생성된 문자열은 직접 수정이 안 됨(immutable) = **불변객체
가볍객체로는 리스트가 있음

12
포매팅은 하나만 알아둬도 오케이
f'{all}이다.'

13
strip, count, join(문자열뿐 아니라 리스트도 가능), index, find, upper, lower

14
Bool True 1 False 0
정수로도 표현 가능

15
연산자

16
**True, False 구분

17
**구조분해할당
sys.stdin.readline().split()  문자열이 split을 통해 리스트로 변환
중요한 건 *을 통해 리스트로 할당한다. 
이를 통해 리스트나 튜플같은 iterable 객체의 요소를 풀어서 개별 변수로 할당할 수 있다..

18
리스트 컴프리헨션 
새로운 리스트를 생성하는데 사용하나, 기존의 리스트를 수정하는데는 사용하지 못함
기존의 리스트를 조작해서 새로운 리스트를 만들 순 있음..??

19
시작과 끝을 구할 때 deque?

20
**시퀀스데이터 타입이자 변경이 가능한 객체는 리스트 데이터뿐
튜플은 시퀀스데이터지만 변경이 불가능하다.. 소괄호는 생략 가능한..

21
딕셔너리는 key 와 value의 대응
키와 값을 하나의 쌍으로 제공
key는 고유한 값이기 때문에 중복을 허용하지 않는다
key에는 리스트가 못 온다. 왜 키는 불변이기 때문에 value에는 리스트가 들어갈 수 있다.
인덱스 이용 못하니까 키를 이용한다..
추가, 수정, 삭제(del사용)

22
----여기부터 함수

1
key값에는 따옴표가 들어가지 않는다
매개변수에서 중요한건 순서가 어떻게 담겨 있는지, 정상적 호출을 위해선 *이 먼저 와야 한다. 
*** (별이 붙은)가변매개변수가 맨앞에.. 그 뒤의 매개변수들은 키워드를 명시해서 사용해야 한다

2
return은 함수가 종료
return문이 생략되면 None을 반환

3
***지역변수, 전역변수
할당을 안 하면 의미가 없다.. global 혹은 return값으로 반환을 해줘야 할당이 된다!!

4
파일 읽고 쓰기 보다는 with문과 함께 쓰는게 중요

-------------------탐색과 정렬(알고리즘이라 파이썬 시험에 없음)
1
순차 탐색 VS 이진 탐색

시간 복잡도 표기법 big-O표기 

2
정렬 알고리즘 중에 최고 성능이 될 수 있는 건...o(n lon n)정도

3
버블, 삽입, 선택 

-----------객체 지향 OOP

-------모듈
import
from
as

----패키지
rrn
.은 디렉만
from은 파일과 디렉 둘 다

------캡슐화***

----다형성 = 오버라이딩 생각해야 함

--finally, raise, except 개념 정도는 알고 있어야!!

---regex 기억 
* 0번이상  
+ 1번이상 
? {0,1}과 동일 즉, 있거나 없거나
() 소괄호는 안 써도 되지만 나중에 group으로 가져올 때 필요함 인덱스처럼..? [0]번 그룹은 없기 때문에 전체 불러옴

------------------
여기부터 알고리즘

--타입힌트 (코드에는 전혀 지장이 없음)
--리스트 컴프리헨션, 딕셔너리 컴프리헨션
--제너레이터
--enumerate 익덱스와 값을 다 가져올 때 편리하게 사용 가능한

--big-O알고리즘 비교할 수 있어야 함! (숫자 5놓고 계산해보셈)

--시간 복잡도는 이해해야해... 이진트리만 비선형이다..

--**투포인터 알고리즘이 언제 적합하냐?
정렬되지 않은 배열에서 특정 요소 찾기,
two Sum 문제에서 같이 두 요소 합이 특정 값이 되는 경우를 찾기,
배열 내에서 특정 조건을 만족하는 부분을 찾을 때
1.하노이(재귀) 2.피보나치 수열(다이나믹) 3... 이런 식의 문제

--선형 자료구조의 연결 방식, 연속방식이 있음
연결 리스트는 연결 방식임
연속 방식은 리스트같은 것
메모리 효율성은 연결이 좋음..

--선형자료구조에서는 큐와 스택의 차이를 아는 것이 중요

--쇠막대기 괜찮은 문제...?^.^

--해시테이블은 중요한 건 해쉬 함수가 있다는 것!
해쉬 함수를 통과하면 동일한 길이의 해쉬코드가 반환된다! (내용은 다름)
***해시 테이블에서 충돌이라는 건, 서로 다른 키를 돌렸는데 값은 값이 나올 때..
체이닝은 안에서 연결리스트를 만들어 충돌이 나면, 연결리스트 방식으로 사용.
오픈어드레싱은 충돌 난 데이터를 비어있는 것과 찾아서 만나게 해줌

--비선형자료구조 -그래프
그래프는 연결 방법, 구성, 시작 노드의 기준 상관없음
**중요한건 순회방법 DFS(깊이우선탐색), BFS(너비우선탐색)  
둘 중에서 스택으로 구현할 수 있는 것은 DFS, 
큐로 구현할 수 있는 건 BFS, 
재귀(재귀는 스택이다/재귀에서 오버플로우가 나는 건 스택이니까 그런거임)로 구현할 수 있는 건 DFS
DFS는 트래킹 알고리즘 가능한..

--비선형 자료 구조 (트리)
그래프의 일종
*루트노드
A만 자식 노드X
**부모노드와 리프노드는 공통될 수 없다

--비선형 자료 구조 (이진 트리)
각 도느가 최대 2개의 자식을 갖는 트리를 의미
**왼쪽 정렬을 해줘야 한다...!!!

--전위순회, 중위순회, 후위순회 (중간이 어디 위치하는지만 알고 있음 됨)

--파이썬으로 구현할 수 있는 건 최소힙

--우선순위 큐는 삽입 순서 상관없이 우선순위가 높아야 된다!!

--정렬알고리즘 
버블, 필요없음
선택정렬, 최소값 앞으로 빼서
삽입정렬, 두번째 요소부터 앞 크기랑 비교
병합정렬, 최고의 천재가 만듦!
퀵정렬, 피벗 이용 최대효율 nlogn

--***안정 정렬VS불안정 정렬
기준은 복잡도나 속도가 아님
기존 입력 데이터에 대한 순서를 유지하냐 못하냐의 차이임!!
병합정렬과 퀵정렬의 차이는 안정 정렬이냐 불안정 정렬이냐의 차이로, 병합이 안전정렬
병합과 퀵의 공통점은 분할정보 알고리즘을 사용한다!!

--***sort함수는 어떤 알고리즘을 사용? 병합과 삽입

--백트래킹 알고리즘
DFS 생각하면 됨
가능성 없는거 삭제한다

--슬라이딩 윈도우 알고리즘
윈도우 크기는 불변 위치만 변경

--색칠횟수 문제 귀엽~!! ?_?

--그리디 알고리즘(탐욕법)
최적의 선택을 하는 것임 
무조건적인 건 없음
완벽한 정답을 갖고 오는 것은 아니지만, 최적을 보장한다
각단계별로 근시안적인 선택으로 최선의 선택을 보장할 수 없다!

--재귀와 분할정복

--다이나믹 프로그래밍 DP 동적계획법 
메모이제이션: 하향식 접근
타뷸레이션: 상향식 접근
***불필요하게 다시 계산하는 걸 막아서 속도 성능을 높여준다.
답이 다시 필요하면 재활용한다
예)피보나치수열같이.., 파스칼의 삼각형...

스택은 위로 데이터가 쌓이는데 맨아래에서 넣는다? 말 안 되죵...












